<#
.SYNOPSIS
    If the directory has a .ps1 or .psm1 file with same name as the directory
       load that file.
       do NOT specifically load any children ( .ps1 or sub folders )
     If the directory does not have a .ps1 or .psm1 file with the same name as the directory
       load the child directories first
       load the .ps1 files next

      TODO: should load_a_directory_into_rails be exported?
#>
Function code_to_load_a_directory
{
    [cmdletbinding()]
    Param (
        [Parameter(Mandatory=$true)][string] $directory_full_path
        ) 
    $same_name_file = ( get_same_name_file -directory_full_path:$directory_full_path )

    if ( $same_name_file -eq $null )
      {
        Write-Debug "We did not find a file named the same as the directory."
        $ret_string = (code_to_load_a_directorys_children -directory_full_path:$directory_full_path)
      }
    else 
      {
        Write-Debug "We did find a file named the same as the directory.  `$same_name_file=[$same_name_file]"
        $ret_string = code_to_load_a_file -file_path_and_name:$same_name_file
      }
  if ( (pr_setting_debug_writes_code_to_load) -eq $true ) { write-host $ret_string }
  return $ret_string
}


Function code_to_load_a_directorys_children
{
    [cmdletbinding()]
    Param (
        [Parameter(Mandatory=$true)][string] $directory_full_path
        ) 
    assert_caller_is_in_my_file

    [string]$ret_code = "<# BEGIN Code generated by:[$($PSCommandPath)] looking over the directory : [$directory_full_path] #>"

    $ret_code += code_to_load_a_directorys_child_directories -directory_full_path:$directory_full_path
    
    $ret_code += code_to_load_a_directorys_child_files -directory_full_path:$directory_full_path

    return $ret_code
}

<#
#>
Function code_to_load_a_directorys_child_files
{
  [cmdletbinding()] Param ( [Parameter(Mandatory=$true)][string] $directory_full_path )  
  assert_caller_is_in_my_file

    [string]$ret_code = "         <# BEGIN Code generated by:[$($PSCommandPath)] looking over the directory : [$directory_full_path] #>
"   
  Write-Debug $ret_code
  $files = (get_child_files -directory_full_path:$directory_full_path -pattern_include:"*.ps1")
  $file_count = 0
  foreach ( $child_file in $files)
  {
      # TODO: once there is an easy way to change the environment to production at the command line, this check for tests needs to be changed to include & env = production
      if ( $child_file.Contains(".Tests.") -eq $true ) { continue }
      $ret_code += code_to_load_a_file $child_file  #given A depends on B, there are no problem importing A first, as long as, during the import of A, A does not call code in B
      $file_count += 1
  }

  [string]$end_code = "
        <# END Code generated by:[$($PSCommandPath)] looking over the directory : [$directory_full_path].  Child files found=[$file_count]. #>"
  Write-Debug $end_code
  [string]$ret_code += $end_code 
  return $ret_code      
}


Function code_to_load_a_directorys_child_directories
{
    [cmdletbinding()] Param ( [Parameter(Mandatory=$true)][string] $directory_full_path ) 
    assert_caller_is_in_my_file

    [string]$ret_code = "         <# BEGIN Code generated by:[$($PSCommandPath)] looking over the directory : [$directory_full_path] #>
" 
    Write-Debug $ret_code
    $child_dir_count = 0
    foreach ( $child_dir in ( get_child_directories -directory_full_path:$directory_full_path ) )
    {
        Write-Debug "Found child directory=[$child_dir] of parent directory=[$directory_full_path]."
        $ret_code += (code_to_load_a_directory -directory_full_path:$child_dir)
        $child_dir_count += 1
    }
    [string]$end_code = "
          <# END Code generated by:[$($PSCommandPath)] looking over the directory : [$directory_full_path].  Child Directories found=[$child_dir_count].#>"
    Write-Debug $end_code
    [string]$ret_code += $end_code 
    return $ret_code
}
